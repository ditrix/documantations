Для стека **React \+ TypeScript** (например, Vite или Next.js) процесс мультиагентного вайб\-кодинга становится еще эффективнее благодаря строгой типизации — агенты используют типы как «контракт» для общения друг с другом.

Вот как это выглядит на практике в Cursor.

## ---

**1\. Проект «Блог» (С нуля)**

Здесь главная фишка — **Type-First Development**. Мы заставляем Архитектора сначала создать интерфейсы, которые потом будут использовать Кодер и UI-специалист.

### **Настройка правил (.cursor/rules/)**

Создайте файлы, специфичные для React/TS:

* **architect.mdc**: «Используй архитектуру Feature-Sliced Design (FSD) или простое разделение на /components, /hooks, /services. Всегда начинай с types.ts.»  
* **ui-specialist.mdc**: «Используй Tailwind CSS \+ Headless UI/Radix. Пиши функциональные компоненты на React с деструктуризацией пропсов и типизацией React.FC или интерфейсами.»

### **Запуск в Composer (Промпт)**

«Создай структуру React-блога на TypeScript.

1. **Architect**: Создай src/types/blog.ts с интерфейсами Post и Comment.  
2. **Coder**: Напиши кастомный хук useComments.ts для управления состоянием комментариев (создание, список) с использованием localStorage для имитации БД.  
3. **UI Specialist**: Создай компонент CommentSection.tsx и CommentForm.tsx. Используй lucide-react для иконок.»

## ---

**2\. Новый функционал: «Авторизация \+ Редактирование»**

Представим, что у нас уже есть Fullstack на **Next.js (App Router)**. Нам нужно добавить проверку прав на фронте и бэке.

### **Шаг 1: Обновление Workflow**

В вашем .cursor/workflow.mdc (или аналогичном файле, который вы использовали в проекте AI CMS) добавляем блок:

* \[ \] Интеграция NextAuth или Clerk (Architect)  
* \[ \] Защищенный API Route для PATCH (Coder)  
* \[ \] Оптимистичное обновление UI через useOptimistic (UI/Coder)

### **Шаг 2: Запуск в Composer (Промпт)**

«Внедряем авторизацию и редактирование.

1. **Architect**: Настрой middleware.ts для защиты роутов редактирования. Добавь поле authorId в типы комментария.  
2. **Coder**: Создай серверный экшн (Server Action) updateComment. Внутри добавь проверку: if (session.user.id \!== comment.authorId) throw new Error("Unauthorized").  
3. **UI Specialist**: В компоненте комментария добавь состояние isEditing. Если оно true — заменяй текст на textarea. Добавь кнопку "Сохранить", которая вызывает серверный экшн.  
4. **QA**: Напиши Playwright или Vitest тест, который проверяет, что кнопка "Edit" не видна неавторизованному пользователю.»

## ---

**Технические нюансы Fullstack (TS)**

При работе с React \+ TS агенты часто спотыкаются на общих типах. Чтобы «вайб» не ломался:

1. **Shared Types**: Храните интерфейсы в одном месте, доступном и для API, и для компонентов.  
2. **Zod Validation**: Попросите **Coder-а** использовать Zod. Это создаст «безопасный мост» между фронтендом и бэкендом:  
   TypeScript  
   // Агент поймет это как единый источник правды  
   const CommentSchema \= z.object({  
     text: z.string().min(3).max(500),  
   });

3. **Error Handling**: Укажите в правилах, чтобы **UI Specialist** всегда добавлял Error Boundaries или toast-notifications при провале запроса.

### **Команды для развертывания (Vercel/Self-hosted)**

Агент с ролью **DevOps** подготовит вам .yml для деплоя:

Bash

npm run build     \# Проверка типов TS и сборка  
npx prisma migrate deploy \# Если есть БД

**Какую часть этого процесса мы разберем детальнее?** Могу написать конкретный ui-specialist.mdc для React, который будет следить за тем, чтобы все формы были доступны (A11y) и типизированы.