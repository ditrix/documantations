Для реализации "Вайб-кодинга" на стеке **React \+ TypeScript (Next.js)** нам нужно адаптировать твою методику «волн» под особенности компонентного подхода и строгой типизации.

Вот готовый набор инструкций и план действий для реализации авторизации и редактирования комментариев.

### ---

**1\. Подготовка среды (Менеджмент ролей)**

В папке .cursor/rules/ создаем (или обновляем) три ключевых .mdc файла. Теперь они будут "заточены" под экосистему React.

**Файл: architect.mdc (Роль: Архитектор)**

Markdown

\---  
description: Проектирование типов, схем БД и структуры API  
globs: \["src/types/**\*\*/*\*.ts", "prisma/schema.prisma", "src/lib/auth.ts"\]***  
***\---***  
***\# Architect Role***  
***1\. Используй Prisma для моделей. Добавь связь User \-\> Comment (1:N).***  
***2\. Определяй Shared Types в \`src/types/index.ts\` для использования на фронте и бэке.***  
***3\. Настрой NextAuth/Auth.js провайдеры и сессии.***

**Файл: coder.mdc (Роль: Бэкенд/Логика)**

Markdown

\---  
description: Бизнес-логика, Server Actions и валидация  
globs: \["src/app/actions/**\*\*/*\*.ts", "src/lib/validation.ts"\]***  
***\---***  
***\# Coder Role***  
***1\. Используй Server Actions (\`'use server'\`) для мутаций.***  
***2\. Проверяй права: \`if (session.user.id \!== comment.authorId) throw new Error("Forbidden")\`.***  
***3\. Валидируй данные через Zod. Возвращай типизированный ответ \`{ data, error }\`.***

**Файл: ui\_specialist.mdc (Роль: UI/UX)**

Markdown

\---  
description: Реализация компонентов и состояний на React  
globs: \["src/components/**\*\*/*\*.tsx", "src/hooks/\*\*/\*.ts"\]***  
***\---***  
***\# UI Specialist Role***  
***1\. Используй Tailwind CSS \+ Lucide Icons.***  
***2\. Реализуй "Inline Editing": текст заменяется на Textarea при нажатии "Edit".***  
***3\. Используй \`useOptimistic\` для мгновенного обновления комментария в списке.***

### ---

**2\. Запуск задачи в Composer (Ctrl+I)**

Теперь мы даем импульс всей системе агентов одним промптом, имитируя твой рабочий процесс:

**Промпт для Cursor:**

"Действуй как команда агентов. Внедряем систему авторизованных комментариев.

1. **Architect**: Добавь поле authorId в модель Comment в schema.prisma. Создай TS-интерфейс CommentUpdateDto.  
2. **Coder**: Напиши Server Action updateComment. Включи проверку сессии пользователя и прав владения комментарием.  
3. **UI Specialist**: В компоненте CommentCard.tsx добавь проверку: если session.user.id \=== comment.authorId, покажи кнопку редактирования. Реализуй режим правки через локальный стейт isEditing.  
4. **QA**: Напиши тест на Vitest, проверяющий, что неавторизованный пользователь получает ошибку при вызове экшена.

Используй правила из .cursor/rules и обнови workflow.mdc по завершении."

### ---

**3\. Визуализация процесса разработки (Vibe Flow)**

В отличие от PHP, где данные часто проходят через контроллеры, в React \+ Next.js взаимодействие идет напрямую между UI и Server Actions через типизированные контракты.

### ---

**4\. Подготовка и развертывание (Командный файл)**

Для React-проекта подготовка и деплой выглядят так:

**Файл: scripts/deploy-vibe.sh** (создается DevOps агентом)

Bash

\#\!/bin/bash  
\# 1\. Инсталляция зависимостей  
npm install

\# 2\. Синхронизация базы (Prisma)  
npx prisma generate  
npx prisma db push

\# 3\. Проверка типов (Важнейший этап для TS)  
npm run type-check

\# 4\. Сборка проекта  
npm run build

**Конфигурация .env:**

Plaintext

DATABASE\_URL="postgresql://..."  
NEXTAUTH\_SECRET="vibe\_secret\_key\_123"  
NEXTAUTH\_URL="http://localhost:3000"

### **5\. Почему это работает лучше?**

* **Контракты типов**: Если Архитектор изменит authorId на userId, TypeScript "подсветит" ошибки во всех файлах Кодера и UI-специалиста. Агенты увидят эти ошибки в контексте Cursor и исправят их автоматически.  
* **Декларативность**: Ты не говоришь "напиши функцию", ты говоришь "внедри функционал", и агенты сами решают, где создать хук, а где серверный компонент.

**Как оцениваешь такую схему для React? Можем сейчас сгенерировать первый файл types.ts для твоего нового блога.**